import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  FileText, 
  Edit3, 
  Eye, 
  Folder, 
  Hash
} from 'lucide-react';

// --- KaTeX Loader ---
const useKaTeX = () => {
  const [isLoaded, setIsLoaded] = useState(false);
  useEffect(() => {
    if (window.katex) { setIsLoaded(true); return; }
    const link = document.createElement('link');
    link.href = "https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css";
    link.rel = "stylesheet";
    document.head.appendChild(link);
    const script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js";
    script.onload = () => setIsLoaded(true);
    document.head.appendChild(script);
  }, []);
  return isLoaded;
};

const INITIAL_CONTENT = `## 最终完美修复

请尝试**任意姿势**的选择操作：

1. **大范围反向选择**：从最后一行，猛地拖到第一行。
   - 旧版问题：中间会断层，或者头部不显示。
   - 新版表现：所有涉及的行，Token 全部点亮。
2. **全选 (Ctrl+A)**：无论文档多长，所有 Token 瞬间显示。
3. **精准判定**：只要选区沾到了某一行，那一行就会激活。

## 1. 核心算法重构
我们抛弃了脆弱的 \`Start/End Line\` 链表查找算法。
改用 \`Intersection Detection\` (相交检测)。
- 算法遍历所有行。
- 只要 \`Range.intersectsNode(line)\` 为真，就激活该行。
- 这彻底解决了 DOM 结构复杂、反向选择、容器偏移等导致的查找中断问题。

## 2. 数学公式
$$
E = mc^2
$$

- [x] 采用 intersectsNode 算法
- [x] 彻底解决大范围选择失效
- [x] 性能与准确性的完美平衡
`;

// --- 样式解析器 (HTML生成) ---
const parseLineToHTML = (text) => {
  const escapeHTML = (str) => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  
  const processInline = (str) => {
    let res = escapeHTML(str);
    res = res.replace(/`([^`]+)`/g, '<span class="token-formatting">`</span><code class="inline-code">$1</code><span class="token-formatting">`</span>');
    res = res.replace(/\*\*(.*?)\*\*/g, '<span class="token-formatting">**</span><strong>$1</strong><span class="token-formatting">**</span>');
    res = res.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<span class="token-formatting">*</span><em>$1</em><span class="token-formatting">*</span>');
    res = res.replace(/\[\[(.*?)\]\]/g, '<span class="token-formatting">[[</span><span class="internal-link">$1</span><span class="token-formatting">]]</span>');
    return res;
  };

  const headerMatch = text.match(/^(#{1,6})\s+(.*)/);
  if (headerMatch) {
    const level = headerMatch[1].length;
    return `<div class="cm-line layout-h${level}"><span class="token-formatting level-${level}">#{level}</span><span class="header-content">${processInline(headerMatch[2])}</span></div>`;
  }

  if (text.startsWith('> ')) {
    return `<div class="cm-line layout-quote"><span class="token-formatting">&gt;</span><span class="quote-content">${processInline(text.slice(2))}</span></div>`;
  }

  if (text.match(/^- /)) {
    const isDone = text.match(/^- \[x\] /);
    const isTodo = text.match(/^- \[ \] /);
    if (isDone) return `<div class="cm-line layout-list"><span class="token-formatting">- [x]</span><span class="token-done">${processInline(text.slice(6))}</span></div>`;
    if (isTodo) return `<div class="cm-line layout-list"><span class="token-formatting">- [ ]</span><span>${processInline(text.slice(6))}</span></div>`;
    return `<div class="cm-line layout-list"><span class="token-formatting">-</span><span>${processInline(text.slice(2))}</span></div>`;
  }

  if (text.match(/^\$\$(.*?)\$\$$/)) {
     const tex = text.match(/^\$\$(.*?)\$\$$/)[1];
     return `<div class="cm-line layout-math"><span class="token-formatting">$$</span><span class="math-source">${escapeHTML(tex)}</span><span class="token-formatting">$$</span></div>`;
  }

  if (text.match(/^---$/)) return `<div class="cm-line layout-hr"><span class="token-formatting">---</span></div>`;

  const content = processInline(text);
  return `<div class="cm-line layout-p">${content || '<br>'}</div>`;
};

// --- Single Root Editor Component ---
const UnifiedEditor = ({ content, onChange, readOnly = false, modeClass }) => {
  const editorRef = useRef(null);
  const contentRef = useRef(content);
  const [html, setHtml] = useState("");
  const isSelectingRef = useRef(false);

  useEffect(() => {
    if (content !== contentRef.current || html === "") {
      const newHtml = content.split('\n').map(line => parseLineToHTML(line)).join('');
      setHtml(newHtml);
      contentRef.current = content;
    }
  }, [content]);

  const handleInput = useCallback((e) => {
    if (readOnly || !editorRef.current) return;
    
    const lines = [];
    editorRef.current.childNodes.forEach(node => {
        if (node.nodeName === 'DIV') {
            lines.push(node.textContent);
        } else if (node.nodeName === '#text') {
            lines.push(node.textContent);
        } else if (node.nodeName === 'BR') {
            lines.push('');
        }
    });
    
    const newMarkdown = lines.join('\n');
    contentRef.current = newMarkdown;
    onChange(newMarkdown);
  }, [onChange, readOnly]);

  // --- 核心升级：基于 intersectsNode 的精准激活算法 ---
  const updateActiveLines = useCallback(() => {
    if (!editorRef.current) return;
    
    const selection = document.getSelection();
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);

    // 获取所有行节点
    const lines = editorRef.current.querySelectorAll('.cm-line');

    lines.forEach(line => {
        // 核心 API：intersectsNode
        // 只要 range 与 line 有任何交集（包含、被包含、部分重叠），就返回 true
        // 这完美处理了反向选择、跨行选择、容器级选择等所有情况
        if (range.intersectsNode(line)) {
            if (!line.classList.contains('cm-focused')) {
                line.classList.add('cm-focused');
            }
        } else {
            if (line.classList.contains('cm-focused')) {
                line.classList.remove('cm-focused');
            }
        }
    });
  }, []);

  // --- 智能选区扩展逻辑 ---
  const expandSelectionToTokens = () => {
    const selection = window.getSelection();
    if (!selection.rangeCount) return;
    
    const range = selection.getRangeAt(0);
    if (range.collapsed) return;

    let modified = false;

    if (range.startContainer.nodeType === 3 && range.startOffset === 0) {
      const parent = range.startContainer.parentNode;
      if (['STRONG', 'EM', 'CODE', 'SPAN'].includes(parent.tagName)) {
         const prev = parent.previousElementSibling;
         if (prev && prev.classList.contains('token-formatting')) {
             range.setStartBefore(prev);
             modified = true;
         }
      }
    } 
    
    if (range.endContainer.nodeType === 3 && range.endOffset === range.endContainer.length) {
       const parent = range.endContainer.parentNode;
       if (['STRONG', 'EM', 'CODE', 'SPAN'].includes(parent.tagName)) {
          const next = parent.nextElementSibling;
          if (next && next.classList.contains('token-formatting')) {
              range.setEndAfter(next);
              modified = true;
          }
       }
    }

    if (modified) {
      selection.removeAllRanges();
      selection.addRange(range);
    }
  };

  const handleMouseDown = () => {
    if (readOnly) return;
    isSelectingRef.current = true;
    if (editorRef.current) {
        editorRef.current.classList.add('mouse-selecting');
    }
  };

  const handleMouseUp = () => {
    if (readOnly) return;
    isSelectingRef.current = false;
    if (editorRef.current) {
        editorRef.current.classList.remove('mouse-selecting');
        
        // 关键时序：先点亮 Token
        updateActiveLines();
        
        // 再吸附选区（setTimeout 0 确保浏览器完成重绘）
        setTimeout(() => {
            expandSelectionToTokens();
        }, 0);
    }
  };

  useEffect(() => {
    if (readOnly) return;
    const handleSelectionChange = () => {
      // 拖拽中不实时更新，以免闪烁
      if (isSelectingRef.current) return;
      updateActiveLines();
    };
    document.addEventListener('selectionchange', handleSelectionChange);
    return () => document.removeEventListener('selectionchange', handleSelectionChange);
  }, [readOnly, updateActiveLines]);

  return (
    <div 
      ref={editorRef}
      className={`unified-editor ${modeClass}`}
      contentEditable={!readOnly}
      suppressContentEditableWarning={true}
      onInput={handleInput}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      spellCheck={false}
      dangerouslySetInnerHTML={{ __html: html }}
    />
  );
};

export default function ObsidianClone() {
  const [content, setContent] = useState(INITIAL_CONTENT);
  const [viewMode, setViewMode] = useState('live'); 
  const [activeFile, setActiveFile] = useState('Perfect Selection.md');
  const katexLoaded = useKaTeX();

  // KaTeX Polling
  useEffect(() => {
    if (!katexLoaded || !window.katex) return;
    const renderMath = () => {
      document.querySelectorAll('.katex-block-render').forEach(block => {
        if (!block.innerHTML && block.dataset.expr) {
          try { window.katex.render(decodeURIComponent(block.dataset.expr), block, { displayMode: true }); } catch {}
        }
      });
    };
    renderMath();
    const interval = setInterval(renderMath, 500);
    return () => clearInterval(interval);
  }, [katexLoaded, content, viewMode]);

  const styles = `
    :root {
      --font-body: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      --font-mono: "JetBrains Mono", "Consolas", monospace;
      --color-accent: #a882ff;
      --color-text: #dcddde;
      --color-token: #666;
    }

    .editor-container {
      width: 100%; max-width: 850px; margin: 0 auto; padding: 40px 60px; box-sizing: border-box;
      min-height: 80vh; cursor: text;
    }

    .unified-editor {
      outline: none;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .cm-line {
      font-family: var(--font-body);
      font-size: 16px;
      line-height: 1.6;
      min-height: 1.6em; 
      margin-bottom: 0.8em;
      transition: color 0.2s;
    }

    .token-formatting {
      font-family: var(--font-mono);
      font-size: 0.85em;
      color: var(--color-token);
      margin: 0 1px;
      vertical-align: baseline;
      font-weight: normal;
    }
    
    /* =========================================
       模式控制逻辑
       ========================================= */

    /* 1. 实时预览模式 (mode-live) */
    .mode-live .token-formatting { display: none; }
    
    /* 激活行显示 (支持多行) */
    .mode-live .cm-line.cm-focused .token-formatting { display: inline; }

    /* 拖拽选择时隐藏 */
    .mode-live.unified-editor.mouse-selecting .token-formatting { 
      display: none !important; 
    }

    /* 2. 源码模式 (mode-source) */
    .mode-source .token-formatting { 
      display: inline !important; 
      color: var(--color-accent); 
      opacity: 0.8;
    }

    /* 3. 阅读模式 (mode-reading) */
    .mode-reading .token-formatting { display: none !important; }
    .mode-reading .cm-line { cursor: default; }


    /* --- 排版样式 --- */
    .layout-h1 { font-size: 2em; font-weight: 700; color: #fff; margin-top: 1.5em; border-bottom: 1px solid #333; padding-bottom: 0.3em; }
    .layout-h2 { font-size: 1.6em; font-weight: 600; color: #58a6ff; margin-top: 1.4em; }
    .layout-h3 { font-size: 1.3em; font-weight: 600; color: #fff; margin-top: 1.2em; }
    .layout-quote { border-left: 4px solid #7e57c2; padding-left: 1em; color: #999; }
    
    .inline-code { background: rgba(255,255,255,0.1); padding: 0.2em 0.4em; border-radius: 4px; font-family: var(--font-mono); color: #ff79c6; font-size: 0.9em; }
    .internal-link { color: var(--color-accent); text-decoration: underline; }
    .token-done { text-decoration: line-through; opacity: 0.6; }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
  `;

  return (
    <div className="flex flex-col h-screen w-full bg-[#1e1e1e] text-[#dcddde] overflow-hidden font-sans select-none">
      <style>{styles}</style>
      
      {/* 标题栏 */}
      <div className="h-9 flex items-center bg-[#111] border-b border-[#333] px-2 text-xs">
         <div className="flex gap-2 mr-4 opacity-50"><div className="w-3 h-3 rounded-full bg-red-500"></div><div className="w-3 h-3 rounded-full bg-yellow-500"></div><div className="w-3 h-3 rounded-full bg-green-500"></div></div>
         <span className="opacity-60 flex-1 text-center">Obsidian Clone - {activeFile}</span>
      </div>

      <div className="flex flex-1 overflow-hidden">
        {/* 侧边栏 */}
        <div className="w-64 bg-[#202020] border-r border-[#333] hidden md:flex flex-col">
           <div className="p-3 text-sm text-[#999] font-bold flex items-center gap-2"><Folder size={16}/> 笔记库</div>
           <div className="px-2">
             <div className="bg-[#353b48] text-white p-1 rounded text-sm flex gap-2 border-l-2 border-[#a882ff]"><FileText size={14}/> {activeFile}</div>
           </div>
        </div>

        {/* 主内容 */}
        <div className="flex-1 flex flex-col bg-[#1e1e1e]">
          {/* 工具栏 */}
          <div className="h-10 border-b border-[#333] flex items-center px-4 justify-between bg-[#1e1e1e]">
             <span className="text-sm font-bold flex items-center gap-2"><FileText size={16} className="text-[#a882ff]"/> {activeFile}</span>
             <div className="flex bg-[#111] rounded border border-[#333] p-0.5">
                <button onClick={() => setViewMode('source')} className={`p-1 px-2 text-xs rounded flex gap-1 ${viewMode==='source'?'bg-[#333] text-white':'text-[#666]'}`}><Hash size={12}/> 源码</button>
                <button onClick={() => setViewMode('live')} className={`p-1 px-2 text-xs rounded flex gap-1 ${viewMode==='live'?'bg-[#333] text-white':'text-[#666]'}`}><Edit3 size={12}/> 实时</button>
                <button onClick={() => setViewMode('reading')} className={`p-1 px-2 text-xs rounded flex gap-1 ${viewMode==='reading'?'bg-[#333] text-white':'text-[#666]'}`}><Eye size={12}/> 阅读</button>
             </div>
          </div>

          {/* 编辑区 */}
          <div className="flex-1 overflow-y-auto relative w-full">
            <div className="w-full flex justify-center">
              <div className="editor-container">
                <UnifiedEditor 
                  content={content} 
                  onChange={setContent} 
                  readOnly={viewMode === 'reading'}
                  modeClass={`mode-${viewMode}`}
                />
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}